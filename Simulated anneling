import random
import math

def calculate_conflicts(state):
    conflicts = 0
    n = len(state)
    for i in range(n):
        for j in range(i + 1, n):
            # Same column
            if state[i] == state[j]:
                conflicts += 1
            # Same diagonal
            elif abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def get_neighbor(state):
    n = len(state)
    neighbor = state.copy()
    row = random.randint(0, n - 1)
    new_col = random.randint(0, n - 1)
    while new_col == neighbor[row]:
        new_col = random.randint(0, n - 1)
    neighbor[row] = new_col
    return neighbor

def simulated_annealing(n, max_iter=100000, initial_temp=100, cooling_rate=0.99):
    current_state = [random.randint(0, n - 1) for _ in range(n)]
    current_energy = calculate_conflicts(current_state)
    temperature = initial_temp

    for iteration in range(max_iter):
        if current_energy == 0:
            return current_state
        
        neighbor = get_neighbor(current_state)
        neighbor_energy = calculate_conflicts(neighbor)
        delta_energy = neighbor_energy - current_energy
        
        if delta_energy < 0 or random.uniform(0, 1) < math.exp(-delta_energy / temperature):
            current_state = neighbor
            current_energy = neighbor_energy
        
        temperature *= cooling_rate
        if temperature < 1e-10:
            break

    return None

def print_board(state):
    n = len(state)
    for row in range(n):
        line = ""
        for col in range(n):
            if state[row] == col:
                line += " Q "
            else:
                line += " . "
        print(line)
    print()

# Run for N=4
n = 4
solution = simulated_annealing(n)

if solution:
    print(f"Solution for {n}-Queens:")
    print_board(solution)
else:
    print("No solution found.")

OUTPUT:

Solution for 4-Queens:
 .  Q  .  . 
 .  .  .  Q 
 Q  .  .  . 
 .  .  Q  . 
